/**
 * PDF Export Service
 * Phase 12.4: Generate court-ready PDF bundles
 *
 * Features:
 * - Cover page with case information
 * - Table of contents
 * - Merge multiple PDFs with separators
 * - Add page numbers
 * - Export by category or by discovery request
 */

import { PDFDocument, StandardFonts, rgb, PDFPage } from "pdf-lib";

export interface ExportDocument {
  id: string;
  fileName: string;
  category: string | null;
  subtype: string | null;
  documentDate: string | null;
  pdfBytes: Uint8Array;
}

export interface ExportOptions {
  caseId: string;
  caseName: string;
  clientName?: string;
  opposingParty?: string;
  caseNumber?: string;
  exportMode: "by_category" | "by_discovery";
  discoveryRequestId?: string;
  discoveryRequestText?: string;
  preparedBy?: string;
  preparedDate?: string;
}

export interface ExportResult {
  pdfBytes: Uint8Array;
  pageCount: number;
  documentCount: number;
  tocEntries: TocEntry[];
}

interface TocEntry {
  title: string;
  category: string;
  pageNumber: number;
}

/**
 * Generate a cover page for the export
 */
async function generateCoverPage(
  options: ExportOptions,
  documentCount: number
): Promise<PDFDocument> {
  const doc = await PDFDocument.create();
  const page = doc.addPage([612, 792]); // Letter size
  const font = await doc.embedFont(StandardFonts.TimesRoman);
  const boldFont = await doc.embedFont(StandardFonts.TimesRomanBold);

  const { width, height } = page.getSize();
  const margin = 72; // 1 inch margins

  // Title
  page.drawText("DOCUMENT PRODUCTION", {
    x: margin,
    y: height - 150,
    size: 24,
    font: boldFont,
    color: rgb(0, 0, 0),
  });

  // Case name
  page.drawText(options.caseName, {
    x: margin,
    y: height - 200,
    size: 18,
    font: boldFont,
    color: rgb(0, 0, 0),
  });

  // Parties
  if (options.clientName || options.opposingParty) {
    const partiesText = options.opposingParty
      ? `${options.clientName || "[Client]"} v. ${options.opposingParty}`
      : options.clientName || "";
    page.drawText(partiesText, {
      x: margin,
      y: height - 230,
      size: 14,
      font: font,
      color: rgb(0.3, 0.3, 0.3),
    });
  }

  // Case number
  if (options.caseNumber) {
    page.drawText(`Case No. ${options.caseNumber}`, {
      x: margin,
      y: height - 260,
      size: 12,
      font: font,
      color: rgb(0.3, 0.3, 0.3),
    });
  }

  // Horizontal line
  page.drawLine({
    start: { x: margin, y: height - 290 },
    end: { x: width - margin, y: height - 290 },
    thickness: 1,
    color: rgb(0.7, 0.7, 0.7),
  });

  // Export type
  const exportTypeText =
    options.exportMode === "by_category"
      ? "Documents Organized by Category"
      : `Response to ${options.discoveryRequestText || "Discovery Request"}`;

  page.drawText(exportTypeText, {
    x: margin,
    y: height - 330,
    size: 14,
    font: boldFont,
    color: rgb(0, 0, 0),
  });

  // Document count
  page.drawText(`Total Documents: ${documentCount}`, {
    x: margin,
    y: height - 360,
    size: 12,
    font: font,
    color: rgb(0.3, 0.3, 0.3),
  });

  // Prepared by section at bottom
  const bottomY = 150;

  page.drawText("Prepared by:", {
    x: margin,
    y: bottomY,
    size: 10,
    font: font,
    color: rgb(0.5, 0.5, 0.5),
  });

  page.drawText(options.preparedBy || "Parency Legal", {
    x: margin,
    y: bottomY - 15,
    size: 10,
    font: font,
    color: rgb(0.5, 0.5, 0.5),
  });

  page.drawText(`Date: ${options.preparedDate || new Date().toLocaleDateString()}`, {
    x: margin,
    y: bottomY - 30,
    size: 10,
    font: font,
    color: rgb(0.5, 0.5, 0.5),
  });

  // Generated by notice
  page.drawText("Generated by Parency Legal - AI-Powered Document Management", {
    x: margin,
    y: 50,
    size: 8,
    font: font,
    color: rgb(0.6, 0.6, 0.6),
  });

  return doc;
}

/**
 * Generate table of contents page
 */
async function generateTocPage(
  tocEntries: TocEntry[],
  totalPages: number
): Promise<PDFDocument> {
  const doc = await PDFDocument.create();
  const font = await doc.embedFont(StandardFonts.TimesRoman);
  const boldFont = await doc.embedFont(StandardFonts.TimesRomanBold);

  let currentPage = doc.addPage([612, 792]);
  const { width, height } = currentPage.getSize();
  const margin = 72;
  let yPosition = height - 100;

  // Title
  currentPage.drawText("TABLE OF CONTENTS", {
    x: margin,
    y: yPosition,
    size: 18,
    font: boldFont,
    color: rgb(0, 0, 0),
  });

  yPosition -= 40;

  // Group entries by category
  const byCategory = tocEntries.reduce((acc, entry) => {
    const cat = entry.category || "Other";
    if (!acc[cat]) acc[cat] = [];
    acc[cat].push(entry);
    return acc;
  }, {} as Record<string, TocEntry[]>);

  for (const [category, entries] of Object.entries(byCategory)) {
    // Check if we need a new page
    if (yPosition < 100) {
      currentPage = doc.addPage([612, 792]);
      yPosition = height - 100;
    }

    // Category header
    currentPage.drawText(category, {
      x: margin,
      y: yPosition,
      size: 12,
      font: boldFont,
      color: rgb(0, 0, 0),
    });
    yPosition -= 20;

    // Entries
    for (const entry of entries) {
      if (yPosition < 80) {
        currentPage = doc.addPage([612, 792]);
        yPosition = height - 100;
      }

      // Truncate long titles
      const maxTitleWidth = 350;
      let displayTitle = entry.title;
      if (font.widthOfTextAtSize(displayTitle, 10) > maxTitleWidth) {
        while (font.widthOfTextAtSize(displayTitle + "...", 10) > maxTitleWidth && displayTitle.length > 0) {
          displayTitle = displayTitle.slice(0, -1);
        }
        displayTitle += "...";
      }

      // Document title
      currentPage.drawText(`    ${displayTitle}`, {
        x: margin,
        y: yPosition,
        size: 10,
        font: font,
        color: rgb(0.2, 0.2, 0.2),
      });

      // Page number (right-aligned)
      const pageNumText = `${entry.pageNumber}`;
      const pageNumWidth = font.widthOfTextAtSize(pageNumText, 10);
      currentPage.drawText(pageNumText, {
        x: width - margin - pageNumWidth,
        y: yPosition,
        size: 10,
        font: font,
        color: rgb(0.2, 0.2, 0.2),
      });

      // Dot leader
      const titleEndX = margin + font.widthOfTextAtSize(`    ${displayTitle}`, 10) + 10;
      const dotsStartX = titleEndX;
      const dotsEndX = width - margin - pageNumWidth - 10;
      const dotText = ".".repeat(Math.floor((dotsEndX - dotsStartX) / 3));
      currentPage.drawText(dotText, {
        x: dotsStartX,
        y: yPosition,
        size: 10,
        font: font,
        color: rgb(0.7, 0.7, 0.7),
      });

      yPosition -= 15;
    }

    yPosition -= 10; // Extra space between categories
  }

  return doc;
}

/**
 * Generate a separator page between documents
 */
async function generateSeparatorPage(
  documentName: string,
  category: string,
  documentNumber: number
): Promise<PDFDocument> {
  const doc = await PDFDocument.create();
  const page = doc.addPage([612, 792]);
  const font = await doc.embedFont(StandardFonts.TimesRoman);
  const boldFont = await doc.embedFont(StandardFonts.TimesRomanBold);

  const { width, height } = page.getSize();

  // Center the content
  const centerY = height / 2;

  // Document number
  page.drawText(`DOCUMENT ${documentNumber}`, {
    x: 72,
    y: centerY + 50,
    size: 14,
    font: boldFont,
    color: rgb(0.4, 0.4, 0.4),
  });

  // Document name
  const nameSize = 16;
  // Truncate if too long
  let displayName = documentName;
  const maxWidth = width - 144;
  if (boldFont.widthOfTextAtSize(displayName, nameSize) > maxWidth) {
    while (boldFont.widthOfTextAtSize(displayName + "...", nameSize) > maxWidth && displayName.length > 0) {
      displayName = displayName.slice(0, -1);
    }
    displayName += "...";
  }

  page.drawText(displayName, {
    x: 72,
    y: centerY + 20,
    size: nameSize,
    font: boldFont,
    color: rgb(0, 0, 0),
  });

  // Category
  page.drawText(`Category: ${category || "Uncategorized"}`, {
    x: 72,
    y: centerY - 20,
    size: 12,
    font: font,
    color: rgb(0.5, 0.5, 0.5),
  });

  return doc;
}

/**
 * Add page numbers to a PDF document
 */
async function addPageNumbers(
  pdfDoc: PDFDocument,
  startPage: number = 1
): Promise<void> {
  const font = await pdfDoc.embedFont(StandardFonts.TimesRoman);
  const pages = pdfDoc.getPages();

  for (let i = 0; i < pages.length; i++) {
    const page = pages[i];
    const { width, height } = page.getSize();
    const pageNum = startPage + i;
    const pageNumText = `Page ${pageNum}`;
    const textWidth = font.widthOfTextAtSize(pageNumText, 10);

    page.drawText(pageNumText, {
      x: (width - textWidth) / 2,
      y: 30,
      size: 10,
      font,
      color: rgb(0.5, 0.5, 0.5),
    });
  }
}

/**
 * Main export function - creates a court-ready PDF bundle
 */
export async function createExportBundle(
  documents: ExportDocument[],
  options: ExportOptions
): Promise<ExportResult> {
  // Sort documents by category then by name
  const sortedDocs = [...documents].sort((a, b) => {
    const catCompare = (a.category || "ZZZ").localeCompare(b.category || "ZZZ");
    if (catCompare !== 0) return catCompare;
    return a.fileName.localeCompare(b.fileName);
  });

  // Create the final merged PDF
  const mergedPdf = await PDFDocument.create();
  const tocEntries: TocEntry[] = [];
  let currentPageNumber = 1;

  // 1. Generate and add cover page
  const coverDoc = await generateCoverPage(options, documents.length);
  const coverPages = await mergedPdf.copyPages(coverDoc, coverDoc.getPageIndices());
  coverPages.forEach((page) => mergedPdf.addPage(page));
  currentPageNumber += coverPages.length;

  // 2. Placeholder for TOC (we'll replace this later)
  const tocStartPage = currentPageNumber;

  // 3. Add each document with separator
  for (let i = 0; i < sortedDocs.length; i++) {
    const doc = sortedDocs[i];

    // Track TOC entry (will update page number after TOC is generated)
    tocEntries.push({
      title: doc.fileName,
      category: doc.category || "Other",
      pageNumber: 0, // Will be updated
    });

    try {
      // Add separator page
      const separatorDoc = await generateSeparatorPage(
        doc.fileName,
        doc.category || "Uncategorized",
        i + 1
      );
      const separatorPages = await mergedPdf.copyPages(
        separatorDoc,
        separatorDoc.getPageIndices()
      );
      separatorPages.forEach((page) => mergedPdf.addPage(page));
      currentPageNumber += separatorPages.length;

      // Update TOC entry with actual page number
      tocEntries[i].pageNumber = currentPageNumber;

      // Add the actual document
      const docPdf = await PDFDocument.load(doc.pdfBytes, {
        ignoreEncryption: true,
      });
      const docPages = await mergedPdf.copyPages(docPdf, docPdf.getPageIndices());
      docPages.forEach((page) => mergedPdf.addPage(page));
      currentPageNumber += docPages.length;
    } catch (error) {
      console.error(`Failed to add document ${doc.fileName}:`, error);
      // Continue with other documents
    }
  }

  // 4. Generate TOC now that we know page numbers
  const tocDoc = await generateTocPage(tocEntries, currentPageNumber);
  const tocPageCount = tocDoc.getPageCount();

  // Adjust all page numbers in TOC entries by TOC page count
  tocEntries.forEach((entry) => {
    entry.pageNumber += tocPageCount;
  });

  // 5. Regenerate TOC with correct page numbers
  const finalTocDoc = await generateTocPage(tocEntries, currentPageNumber + tocPageCount);

  // 6. Create final document with correct order
  const finalPdf = await PDFDocument.create();

  // Add cover page
  const finalCoverPages = await finalPdf.copyPages(coverDoc, coverDoc.getPageIndices());
  finalCoverPages.forEach((page) => finalPdf.addPage(page));

  // Add TOC
  const finalTocPages = await finalPdf.copyPages(finalTocDoc, finalTocDoc.getPageIndices());
  finalTocPages.forEach((page) => finalPdf.addPage(page));

  // Add all document pages (skip cover from merged)
  const allMergedPages = mergedPdf.getPages();
  const docPagesStart = coverPages.length; // Skip cover pages
  for (let i = docPagesStart; i < allMergedPages.length; i++) {
    const [copiedPage] = await finalPdf.copyPages(mergedPdf, [i]);
    finalPdf.addPage(copiedPage);
  }

  // 7. Add page numbers
  await addPageNumbers(finalPdf);

  // 8. Serialize
  const pdfBytes = await finalPdf.save();

  return {
    pdfBytes: new Uint8Array(pdfBytes),
    pageCount: finalPdf.getPageCount(),
    documentCount: documents.length,
    tocEntries,
  };
}
