/**
 * PDF Export Utilities
 * Phase 9: Timeline, Search & Export
 *
 * Helper functions for PDF generation and document organization
 */

import { SelectDocument } from "@/db/schema";

// Types
export interface ExportOptions {
  format: "pdf" | "csv" | "xlsx";
  includeMetadata: boolean;
  includeTableOfContents: boolean;
  includeCoverPage: boolean;
  groupBy: "category" | "date" | "none";
  sortBy: "date" | "category" | "name";
  sortOrder: "asc" | "desc";
}

export interface CoverPageData {
  caseName: string;
  caseNumber?: string;
  exportDate: Date;
  documentCount: number;
  exportedBy?: string;
}

export interface TocEntry {
  fileName: string;
  pageNumber: number;
  category: string | null;
}

export interface FormattedDocument {
  id: string;
  fileName: string;
  safeFileName: string;
  category: string | null;
  subtype: string | null;
  dateFormatted: string | null;
  metadata: Record<string, any> | null;
}

/**
 * Generate cover page HTML content
 */
export function generateCoverPage(data: CoverPageData): string {
  const dateStr = data.exportDate.toLocaleDateString("en-US", {
    year: "numeric",
    month: "long",
    day: "numeric",
  });

  return `
<div class="cover-page">
  <h1>${escapeHtml(data.caseName)}</h1>
  ${data.caseNumber ? `<h2>Case No. ${escapeHtml(data.caseNumber)}</h2>` : ""}
  <div class="cover-info">
    <p><strong>Document Export</strong></p>
    <p>Date: ${dateStr}</p>
    <p>Total Documents: ${data.documentCount}</p>
    ${data.exportedBy ? `<p>Exported by: ${escapeHtml(data.exportedBy)}</p>` : ""}
  </div>
  <div class="cover-footer">
    <p>Generated by Parency Legal</p>
  </div>
</div>
`.trim();
}

/**
 * Generate table of contents HTML content
 */
export function generateTableOfContents(
  documents: TocEntry[],
  options?: { groupByCategory?: boolean }
): string {
  if (documents.length === 0) {
    return "<div class='toc'><h2>Table of Contents</h2><p>No documents included in this export.</p></div>";
  }

  const lines: string[] = ["<div class='toc'>", "<h2>Table of Contents</h2>"];

  if (options?.groupByCategory) {
    // Group by category
    const grouped = new Map<string, TocEntry[]>();

    for (const doc of documents) {
      const cat = doc.category || "Uncategorized";
      if (!grouped.has(cat)) {
        grouped.set(cat, []);
      }
      grouped.get(cat)!.push(doc);
    }

    // Sort categories alphabetically
    const sortedCategories = Array.from(grouped.keys()).sort();

    for (const category of sortedCategories) {
      lines.push(`<h3>${escapeHtml(category)}</h3>`);
      lines.push("<ul>");

      for (const doc of grouped.get(category)!) {
        lines.push(
          `<li><span class="toc-entry">${escapeHtml(doc.fileName)}</span>` +
            `<span class="toc-page">Page ${doc.pageNumber}</span></li>`
        );
      }

      lines.push("</ul>");
    }
  } else {
    // Simple list
    lines.push("<ul>");
    for (const doc of documents) {
      lines.push(
        `<li><span class="toc-entry">${escapeHtml(doc.fileName)}</span>` +
          `<span class="toc-page">Page ${doc.pageNumber}</span></li>`
      );
    }
    lines.push("</ul>");
  }

  lines.push("</div>");
  return lines.join("\n");
}

/**
 * Group documents by category
 */
export function groupDocumentsByCategory(
  documents: Array<{ id: string; category: string | null; fileName: string }>
): Record<string, typeof documents> {
  const grouped: Record<string, typeof documents> = {};

  for (const doc of documents) {
    const cat = doc.category || "Uncategorized";
    if (!grouped[cat]) {
      grouped[cat] = [];
    }
    grouped[cat].push(doc);
  }

  // Return sorted by category name
  const sorted: Record<string, typeof documents> = {};
  const sortedKeys = Object.keys(grouped).sort();

  for (const key of sortedKeys) {
    sorted[key] = grouped[key];
  }

  return sorted;
}

/**
 * Group documents by date (month or year)
 */
export function groupDocumentsByDate(
  documents: Array<{ id: string; documentDate: Date | null; fileName: string }>,
  grouping: "month" | "year" = "month"
): Record<string, typeof documents> {
  const grouped: Record<string, typeof documents> = {};

  for (const doc of documents) {
    let key: string;

    if (!doc.documentDate) {
      key = "No Date";
    } else {
      const date = new Date(doc.documentDate);
      if (grouping === "year") {
        key = String(date.getFullYear());
      } else {
        key = date.toLocaleDateString("en-US", {
          year: "numeric",
          month: "long",
        });
      }
    }

    if (!grouped[key]) {
      grouped[key] = [];
    }
    grouped[key].push(doc);
  }

  return grouped;
}

/**
 * Format a document for export with sanitized fields
 */
export function formatDocumentForExport(doc: {
  id: string;
  fileName: string;
  category: string | null;
  subtype: string | null;
  documentDate: Date | null;
  metadata: Record<string, any> | null;
}): FormattedDocument {
  return {
    id: doc.id,
    fileName: doc.fileName,
    safeFileName: sanitizeFileName(doc.fileName),
    category: doc.category,
    subtype: doc.subtype,
    dateFormatted: doc.documentDate
      ? new Date(doc.documentDate).toLocaleDateString("en-US", {
          year: "numeric",
          month: "short",
          day: "numeric",
        })
      : null,
    metadata: doc.metadata,
  };
}

/**
 * Calculate estimated export size in bytes
 */
export function calculateExportSize(
  documentCount: number,
  options: Partial<ExportOptions>
): number {
  // Base overhead (PDF headers, fonts, etc.)
  let size = 50000; // 50KB base

  // Per-document estimate (varies widely, using 100KB average)
  size += documentCount * 100000;

  // Cover page adds ~10KB
  if (options.includeCoverPage) {
    size += 10000;
  }

  // Table of contents adds ~5KB + 200 bytes per entry
  if (options.includeTableOfContents) {
    size += 5000 + documentCount * 200;
  }

  // Metadata adds ~1KB per document
  if (options.includeMetadata) {
    size += documentCount * 1000;
  }

  return size;
}

/**
 * Validate export options
 */
export function validateExportOptions(options: Partial<ExportOptions>): {
  valid: boolean;
  errors: string[];
  normalized: ExportOptions;
} {
  const errors: string[] = [];

  // Validate format
  const validFormats = ["pdf", "csv", "xlsx"];
  if (options.format && !validFormats.includes(options.format)) {
    errors.push(`Invalid format: ${options.format}. Must be one of: ${validFormats.join(", ")}`);
  }

  // Validate groupBy
  const validGroupBy = ["category", "date", "none"];
  if (options.groupBy && !validGroupBy.includes(options.groupBy)) {
    errors.push(`Invalid groupBy: ${options.groupBy}. Must be one of: ${validGroupBy.join(", ")}`);
  }

  // Validate sortBy
  const validSortBy = ["date", "category", "name"];
  if (options.sortBy && !validSortBy.includes(options.sortBy)) {
    errors.push(`Invalid sortBy: ${options.sortBy}. Must be one of: ${validSortBy.join(", ")}`);
  }

  // Validate sortOrder
  const validSortOrder = ["asc", "desc"];
  if (options.sortOrder && !validSortOrder.includes(options.sortOrder)) {
    errors.push(`Invalid sortOrder: ${options.sortOrder}. Must be one of: ${validSortOrder.join(", ")}`);
  }

  // Build normalized options with defaults
  const normalized: ExportOptions = {
    format: options.format || "pdf",
    includeMetadata: options.includeMetadata ?? true,
    includeTableOfContents: options.includeTableOfContents ?? true,
    includeCoverPage: options.includeCoverPage ?? true,
    groupBy: options.groupBy || "category",
    sortBy: options.sortBy || "date",
    sortOrder: options.sortOrder || "asc",
  };

  return {
    valid: errors.length === 0,
    errors,
    normalized,
  };
}

/**
 * Sanitize file name by removing illegal characters
 */
function sanitizeFileName(fileName: string): string {
  // Remove characters that are invalid in file systems
  return fileName
    .replace(/[<>:"/\\|?*]/g, "_")
    .replace(/\s+/g, "_")
    .replace(/_+/g, "_")
    .trim();
}

/**
 * Escape HTML special characters
 */
function escapeHtml(text: string): string {
  const map: Record<string, string> = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#039;",
  };
  return text.replace(/[&<>"']/g, (m) => map[m]);
}
